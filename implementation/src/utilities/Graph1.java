package utilities;

import java.security.InvalidAlgorithmParameterException;
import java.util.ArrayList;
import java.util.List;

public class Graph1 {
	String name = "";
	private int idGenerator = 0 ;
	private ArrayList<ArrayList<Edge>> edges = new ArrayList<ArrayList<Edge>>(); 
	private int vSize, eSize;
	
	
	//----Constructors----
	public Graph1 (int size) {
		this.vSize = size;
		for(int i = 0 ; i < size ; i++)
			edges.add(new ArrayList<Edge>());
		
	}
	
	//----Accessors----
	public int size() {return eSize + vSize;}
	
	public Graph1 stringToGraph (String str ) {
		//Pyramid shape  for the edges : 0-1   0-2   0-3   0-4
		//									1-2   1-3   1-4
		//									   2-3   2-4
		//										  3-4
		
		
		Graph1 ret = new Graph1(vSize);
		
		int currentVertex = 0;
		int neigborVertex = 1;

		//Scan the string
		for(char bit : str.toCharArray()) {
			if(bit == '1') {
				try {
					ret.addEdge(currentVertex , neigborVertex);
				} catch (InvalidAlgorithmParameterException e) {
					e.printStackTrace();
				}
				
			}
			
			//According to the pyramid on top
			neigborVertex++;
			if(neigborVertex == vSize) {
				currentVertex++;
				neigborVertex = currentVertex + 1;
			}
			
		}
				
		return ret;
	}
	
	public double weight () {
		double w = 0;
		
		for (int i = 0 ; i < edges.size() ; i++)
			for(int j = 0 ; j < edges.get(i).size() ; j++) 
				w += edges.get(i).get(j).getWeight();
		
		/*Each edge is counted twice , one at the source vertex
		 *  and one at the destiny vertex.
		 *  Therefore eventually divide by 2.*/
		return w / 2;
	}
	
	
	
	public boolean isDegenerated () {
		final int FIRST = 0 ;
		
		if(eSize != vSize - 1)return false;
		/*Less than v-1 vertices will result a graph that is not spanning the original graph.
		 * More than v-1 vertices will result necessarily a circle which is not degenerated by definition.*/
		
		
		ArrayList<ArrayList<Edge>> leftEdges = copyEdges(edges);
		
		Edge curEdge = null;
		int curVertex = 0;
		boolean [] areVisited = new boolean [vSize];

		//Find the first vertex
		for(int i = 0 ; i < leftEdges.size() ; i++) 
			if(!leftEdges.get(i).isEmpty()) {
				curEdge = leftEdges.get(i).remove(FIRST);
				curVertex = i;
				areVisited[curVertex] = true;
				break;
			}

		
		//Scan from a vertex to his neighbors
		for(;;) {
			
			curVertex = inferNext(curEdge, curVertex);
			
			//Do not visit a twice a vertex
			if(areVisited[curVertex] == true)
				return false;
			else 
				areVisited[curVertex] = true;
			
			removeEdge(curEdge.getU(), curEdge.getV(), leftEdges.get(curVertex));
			
			if(leftEdges.get(curVertex).isEmpty())
				break;
			
			else {
				curEdge = leftEdges.get(curVertex).remove(FIRST);
			}
		}
		
		
		//Final check
		for(ArrayList<Edge> vertex : leftEdges)
			if(!vertex.isEmpty())return false;
		return true;
	}
		

	
	public List<String> findPermutations() {
		List<String> allPermutations = new ArrayList<String>();
		final int MAX_GRAPH_EDGES = vSize *(vSize - 1) / 2;
		final int SPANNING_TREE_EDGES = vSize - 1;
		findPermutations(MAX_GRAPH_EDGES,SPANNING_TREE_EDGES, allPermutations, ""); 
		// A spanning tree must have precisely v - 1 edges
		return allPermutations;
	}
	
	
	public void findPermutations (int n , int r , List<String> pers , String curPer) {
		
		if(curPer.length() == n && countOnes(curPer) == r)
			pers.add(curPer);
		
		if(curPer.length() < n) {
			findPermutations(n, r, pers, curPer + "0");
			findPermutations(n, r, pers, curPer + "1");
		}
	}
	
	public String toString () {
		String ret = "Graph " + name + ":\n";
		for(int i = 0 ; i < edges.size() ; i++) {
			ret += "(" + i + ")-[" ;
			for(int j = 0 ; j < edges.get(i).size() ; j++)
				ret += edges.get(i).get(j);
			
			ret+="]\n";
		}
		return ret;
	}
	
	//----Mutators----
	public void addEdge (int v , int u,double w ) throws InvalidAlgorithmParameterException {
		//v == vertex 1 , u == vertex 2 , w == weight
		if(v == u)
			throw new InvalidAlgorithmParameterException("No self edges");
		Edge e = new Edge(v , u , w);
		
		
		for(int i = 0  ;i < edges.size() ; i++)
			for(int j = 0 ; j < edges.get(i).size() ; j++)
				if(edges.get(i).equals(e))
					throw new InvalidAlgorithmParameterException("This edge already exists");

		
		/*Operation was not successful,
		 * a vertex v could not have more 
		 * then one edge to the another
		 *  vertex u*/
		edges.get(u).add(e);
		edges.get(v).add(e);
		eSize++;
	}
	
	public void addEdge (int v , int u) throws InvalidAlgorithmParameterException {
		//v == vertex 1 , u == vertex 2 , w == weight
		if(v == u)
			throw new InvalidAlgorithmParameterException("No self edges");
		Edge e = new Edge(v , u );
		
		
		for(int i = 0  ;i < edges.size() ; i++)
			for(int j = 0 ; j < edges.get(i).size() ; j++)
				if(edges.get(i).equals(e))
					throw new InvalidAlgorithmParameterException("This edge already exists");

		
		/*Operation was not successful,
		 * a vertex v could not have more 
		 * then one edge to the another
		 *  vertex u*/
		edges.get(u).add(e);
		edges.get(v).add(e);
		eSize++;
	}

	
	//----Class methods----
	public static int countOnes (String str) {
		int counter = 0;
		for(char c : str.toCharArray())
			if(c == '1' )
				counter++;
		return counter;
	}
	
	public static ArrayList<ArrayList<Edge>> copyEdges (ArrayList<ArrayList<Edge>> original){
		ArrayList<ArrayList<Edge>> copy = new ArrayList<>();
		
		for (ArrayList<Edge> vertexEdges : original )
			copy.add(new ArrayList<Edge>(vertexEdges));
		
		return copy;
		
	}
	
	public static int inferNext(Edge edge , int vertex) {
		if(edge.getU() == vertex)
			return edge.getV();
		else
			return edge.getU();
		
	}
	
	public static void removeEdge (int u , int v , ArrayList<Edge> list) {
		Edge e = new Edge(u , v);
		
		int i = 0 ;
		for(; i < list.size() ; i++) 
			if(list.get(i).equals(e)) {
				list.remove(i);
				i--;
			}
	}
	
	public int maxEdges () {
		return vSize*(vSize - 1) / 2;
	}
	


}
