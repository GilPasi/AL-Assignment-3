package utilities;
import java.security.InvalidAlgorithmParameterException;
import java.util.ArrayList;
import java.util.List;

public class Map {
	//Equivalent to a graph

	String name = " ";
	private ArrayList<ArrayList<Path>> paths = new ArrayList<ArrayList<Path>>(); 
	private int machineCount, pathCount; // == |V| , |E| respectively
	private double maxPath = Double.MIN_VALUE;

	//----Constructors----
	public Map (int size) {
		this.machineCount = size;
		for(int i = 0 ; i < size ; i++)
			paths.add(new ArrayList<Path>());
		
	}
	
	//----Accessors----
	public int size() {return pathCount + machineCount;}
	
	
	public double weight () {
		double w = 0;
		
		for (int i = 0 ; i < paths.size() ; i++)
			for(int j = 0 ; j < paths.get(i).size() ; j++) 
				w += paths.get(i).get(j).getWeight();
		
		/*Each edge is counted twice , one at the source vertex
		 *  and one at the destiny vertex.
		 *  Therefore eventually divide by 2.*/
		return w / 2;
	}
	
	
	public Map stringToGraph (String str ) {
		//Pyramid shape  for the paths : 0-1   0-2   0-3   0-4
		//									1-2   1-3   1-4
		//									   2-3   2-4
		//										  3-4
		
		
		Map ret = new Map(machineCount);
		
		int currentMachine = 0;
		int neigborMachine = 1;

		//Scan the string
		for(char bit : str.toCharArray()) {
			if(bit == '1') {
				try {
					ret.addPath(currentMachine , neigborMachine);
				} catch (InvalidAlgorithmParameterException e) {
					e.printStackTrace();
				}
				
			}
			
			//According to the pyramid on top
			neigborMachine++;
			if(neigborMachine == machineCount) {
				currentMachine++;
				neigborMachine = currentMachine + 1;
			}
			
		}
				
		return ret;
	}

	
	public boolean isDegenerated () {
		/**This method finds out if a given map is a degenerated spanning tree.
		 * It does so by performing which resembles DFS. The only difference is 
		 * within the fact that there is no turning back once a vertex has been reached.
		 * Meaning a circle is not possible.At the end of the method it will check if any of the 
		 * vertices (machines) have not been visited , this is a sign of a non spanning tree.*/
		
		final int FIRST = 0 ;
		
		if(pathCount != machineCount - 1)return false;
		/*Less than v-1 vertices will result a graph that is not spanning the original graph.
		 * More than v-1 vertices will result necessarily a circle which is not degenerated by definition.*/
		
		
		ArrayList<ArrayList<Path>> leftpaths = copyPaths(paths);
		
		Path curPath = null;
		int curMachine = 0;
		boolean [] areVisited = new boolean [machineCount];

		//Find the first vertex
		for(int i = 0 ; i < leftpaths.size() ; i++) 
			if(!leftpaths.get(i).isEmpty()) {
				curPath = leftpaths.get(i).remove(FIRST);
				curMachine = i;
				areVisited[curMachine] = true;
				break;
			}

		
		//Scan from a vertex to his neighbors
		for(;;) {
			curMachine = inferNext(curPath, curMachine);
			
			//Do not visit a twice a vertex
			if(areVisited[curMachine] == true)
				return false;
			else 
				areVisited[curMachine] = true;
			
			removePath(curPath.getU(), curPath.getV(), leftpaths.get(curMachine));
			
			if(leftpaths.get(curMachine).isEmpty())
				break;
			
			else {
				curPath = leftpaths.get(curMachine).remove(FIRST);
			}
		}
		
		
		//Final check
		for(ArrayList<Path> vertex : leftpaths)
			if(!vertex.isEmpty())return false;
		return true;
	}
		
	public List<String> findPermutations() {
		/**The shortest/lightest journey must include all the branches.
		 * Meaning no less than |V| vertices. On the other hand it should aspire for
		 * the least amount of edges (paths) as possible.
		 * Therefore it must be a degenerated tree.
		 * This method focus on getting all possible trees permutations.
		 * A spanning tree / spanning map must have exactly |V| vertices and |V|-1 edges.
		 * The total amount of possible edges in an undirected graph is |V|*(|V|-1) / 2.
		 * This the reason for searching all the permutations of nPr while n = |V|*(|V|-1) / 2 , r = |V|-1 .
		 * */
		
		List<String> allPermutations = new ArrayList<String>();
		final int MAX_MAP_PATHS_COUNT = machineCount *(machineCount - 1) / 2;// V*(V-1) /2
		final int SPANNING_MAP_PATHS_COUNT = machineCount - 1;//V-1
		findPermutations(MAX_MAP_PATHS_COUNT,SPANNING_MAP_PATHS_COUNT, allPermutations, ""); 
		// A spanning tree must have precisely v - 1 paths
		return allPermutations;
	}
	
	
	public void findPermutations (int n , int r , List<String> pers , String curPer) {
		
		if(curPer.length() == n && countOnes(curPer) == r)
			pers.add(curPer);
		
		if(curPer.length() < n) {
			findPermutations(n, r, pers, curPer + "0");
			findPermutations(n, r, pers, curPer + "1");
		}
	}
	
	public String toString () {
		String ret = "Map" + name + ":\n";
		for(int i = 0 ; i < paths.size() ; i++) {
			ret += "(" + i + ")-[" ;
			for(int j = 0 ; j < paths.get(i).size() ; j++)
				ret += paths.get(i).get(j);
			
			ret+="]\n";
		}
		return ret;
	}
	
	//----Mutators----
	public void addPath (int v , int u,double w ) throws InvalidAlgorithmParameterException {
		//v == machine1, u == machine2 w == weight
		if(v == u)
			throw new InvalidAlgorithmParameterException("No self paths");
		Path p = new Path(v , u , w);
		
		
		for(int i = 0  ;i < paths.size() ; i++)
			for(int j = 0 ; j < paths.get(i).size() ; j++)
				if(paths.get(i).equals(p))
					throw new InvalidAlgorithmParameterException("This path already exists");

		
		/*Operation was not successful,
		 * a vertex v could not have more 
		 * then one edge to the another
		 *  vertex u*/
		paths.get(v).add(p);
		paths.get(u).add(p);
		pathCount++;
	}
	
	public void addPath (int v , int u) throws InvalidAlgorithmParameterException {
		//v == machine1, u == machine2 w == weight
		if(v == u)
			throw new InvalidAlgorithmParameterException("No self paths");
		Path p = new Path(v , u );
		
		
		for(int i = 0  ;i < paths.size() ; i++)
			for(int j = 0 ; j < paths.get(i).size() ; j++)
				if(paths.get(i).equals(p))
					throw new InvalidAlgorithmParameterException("This edge already exists");

		
		/*Operation was not successful,
		 * a vertex v could not have more 
		 * then one edge to the another
		 *  vertex u*/
		paths.get(v).add(p);
		paths.get(u).add(p);
		pathCount++;
		
	}

	
	//----Class methods----
	public static int countOnes (String str) {
		int counter = 0;
		for(char c : str.toCharArray())
			if(c == '1' )
				counter++;
		return counter;
	}
	
	public static ArrayList<ArrayList<Path>> copyPaths (ArrayList<ArrayList<Path>> original){
		ArrayList<ArrayList<Path>> copy = new ArrayList<>();
		
		for (ArrayList<Path> vertexpaths : original )
			copy.add(new ArrayList<Path>(vertexpaths));
		
		return copy;
		
	}
	
	public static int inferNext(Path path , int machine) {
		if(path.getU() == machine)
			return path.getV();
		else
			return path.getU();
		
	}
	
	public static void removePath (int v , int u , ArrayList<Path> list) {
		Path p = new Path(v , u);
		
		int i = 0 ;
		for(; i < list.size() ; i++) 
			if(list.get(i).equals(p)) {
				list.remove(i);
				i--;
			}
	}
	public static double road (String city1 , String city2 , double x1 , double x2 ,double y1 , double y2) {	
		
		final double  EXTRA_SPEED = 70 , INTRA_SPEED  = 30 ,//kph
				FILL_TIME = 5,CITIES_TRANSFER_TIME = 6 ;//mins	
		
		
		double distance = Math.sqrt(
				Math.pow(x1 - x2 , 2) 
				+ 
				Math.pow(y1 - y1 , 2) 	
				);
		double time = 0;
		
		
		if(city1.equals(city2))
			time = distance / INTRA_SPEED + FILL_TIME;
		else 
			time = distance / EXTRA_SPEED + FILL_TIME + CITIES_TRANSFER_TIME;
		
		
		return time;
	}
	
	
	public static double weight (String city1 , String city2 , double x1 , double x2 ,double y1 , double y2 , int priority) {	
		
		double weight =  road(city1, city2, x1, x2, y1, y2);
		
//		if(priority > 0)
		
		return weight;
	}
	
	
}
